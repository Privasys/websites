---
title: Why Privasys
description: The trust problem in cloud computing and how Privasys solves it with confidential computing and RA-TLS.
---

## The Trust Problem

Cloud computing requires handing over your data and code to a third party. Even with encryption at rest and in transit, there is a fundamental gap: **data must be decrypted to be processed**, and during that window the cloud provider, the host OS, the hypervisor, and any privileged attacker can observe it.

Confidential Computing closes this gap by running workloads inside hardware-enforced Trusted Execution Environments (TEEs). Technologies like Intel SGX and Intel TDX ensure that memory is encrypted, CPU state is isolated, and even a compromised hypervisor cannot peek inside.

But hardware isolation alone is insufficient. A critical UX problem remains:

> **How does a remote client know it's actually talking to a genuine TEE running the expected code?**

The traditional answer — remote attestation — requires custom client-side code, specialised SDKs, and an out-of-band attestation flow that is alien to the browser-based web.

## Our Approach

Privasys takes a different path. Instead of asking every client to speak a custom attestation protocol, we embed the attestation evidence **directly into standard TLS certificates**. This technique is called **RA-TLS** (Remote Attestation TLS), and it means:

- **Zero client-side changes.** Any TLS client — a browser, `curl`, a mobile app — can connect without modification. HTTPS just works.
- **Composable with existing PKI.** The RA-TLS certificate is signed by a private CA, chaining into your organisation's existing trust hierarchy.
- **Cryptographic binding.** The hardware quote's `ReportData` contains a hash of the TLS public key, making the attestation inseparable from the TLS session.
- **Verifiable by anyone.** A relying party extracts the quote from a standard X.509 extension and verifies it against the chip vendor's attestation infrastructure.

## What Privasys Provides

Privasys is not a hosted platform. It is **open-source infrastructure** that you deploy on your own hardware or cloud instances:

### Enclave OS (Mini)

A minimal OS layer for Intel SGX enclaves, written entirely in Rust. It provides RA-TLS ingress, an encrypted key-value store, MRENCLAVE-sealed configuration, and a WASM runtime for running arbitrary business logic inside the enclave — all communicating with the untrusted host through lock-free circular buffers instead of traditional OCALLs.

→ [Enclave OS documentation](/solutions/enclave-os/architecture)

### Caddy RA-TLS Module

A `tls.issuance` module for the [Caddy](https://caddyserver.com/) web server that produces RA-TLS certificates for Confidential VMs (Intel TDX, AMD SEV-SNP planned). Caddy handles TLS termination, certificate caching, and renewal; our module generates keys inside the TEE, obtains hardware quotes, and signs certificates. Supports both deterministic and challenge-response attestation.

→ [Confidential Containers documentation](/solutions/confidential-containers/concept)

### RA-TLS Clients

Multi-language client libraries (Python, Go, Rust, TypeScript, C#/.NET) for connecting to RA-TLS servers. Each client demonstrates how to verify attested TLS connections using custom CA trust roots.

→ [RA-TLS Clients documentation](/solutions/clients)

### Attestation Server

A lightweight Go server that verifies hardware attestation quotes from Intel TDX and SGX platforms, secured with Ed25519 JWT authentication. It provides a REST API for validating quotes independently of the TLS layer.

→ [Attestation Server guide](/guides/attestation-server)

## Two Deployment Models

Confidential computing hardware comes in two fundamentally different forms. Rather than force a one-size-fits-all solution, Privasys provides a dedicated stack for each:

| | **Enclave OS** (Intel SGX) | **Caddy RA-TLS Module** (Intel TDX / AMD SEV-SNP) |
|--|---------------------------|------------------------------------------|
| **What it protects** | A single application inside a hardware enclave | An entire virtual machine with encrypted memory |
| **Trusted Computing Base** | ~4 MB enclave binary — minimal attack surface | Full Linux VM + Caddy — larger, but standard |
| **How you deploy** | Custom Rust build, SGX SDK, signed enclave | Standard Linux binary, xcaddy, no special SDK |
| **How apps run** | WASM modules loaded into the enclave | Any process in the VM; Caddy acts as reverse proxy |
| **RA-TLS certificate** | CA-signed, enclave-generated (intermediary CA sealed inside SGX) | CA-signed, TEE-generated (intermediary CA on filesystem) |

**Choose Enclave OS (Mini)** when you need the smallest possible attack surface and strong per-application isolation — ideal for security-critical workloads where minimising the Trusted Computing Base is paramount.

**Choose the Caddy RA-TLS Module** when you want to add attestation to existing applications with minimal changes — just place a Caddy reverse proxy inside a Confidential VM and configure the RA-TLS issuer.

Both paths produce standard RA-TLS certificates that can be verified by the same [RA-TLS client libraries](/solutions/clients). The choice of TEE backend is transparent to clients — they see a normal HTTPS connection either way.

## Design Principles

| Principle | How |
|-----------|-----|
| **Minimal TCB** | The Enclave OS is ~4 MB signed. Only essential code runs inside the enclave. |
| **Standard protocols** | TLS 1.3, X.509, HTTPS. No custom wire protocols exposed to clients. |
| **Defence in depth** | Hardware isolation (SGX/TDX) + WASM sandboxing + encrypted storage + Merkle-attested configuration. |
| **Open source** | All infrastructure is AGPL-3.0. Inspect, audit, and build from source. |
| **No vendor lock-in** | Deploy on any SGX/TDX/SEV-capable hardware. The Caddy module's `Attester` interface supports pluggable backends (TDX today, SEV-SNP planned). |

## Honest by Design

Traditional cloud requires you to *trust* the provider. Privasys replaces trust with **verification**:

- The enclave's identity (MRENCLAVE) proves exactly which code is running.
- The RA-TLS certificate proves the TLS key was generated inside that enclave.
- The Config Merkle root proves exactly which CA, modules, and WASM applications are loaded.
- All of this is embedded in a standard X.509 certificate that any client can inspect.

**Don't trust. Verify.**
